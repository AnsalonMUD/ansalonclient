<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE muclient
[
  <!ENTITY PreserveLineBreaksWanted "vbTrue" > 
  <!ENTITY LogOutputWanted "vbTrue" > 
  <!ENTITY LogCommandsWanted "vbTrue" > 
]>
<!-- Saved on Friday, July 25, 2003, 10:50 AM -->
<!-- MuClient version 3.42 -->

<!-- Plugin "ANSI_Log" generated by Plugin Wizard -->

<!--
You can change the entities at the top to control the way it works.

PreserveLineBreaksWanted = Whether or not each line ends with a hard carriage return
LogOutputWanted = Whether output from the MUD is to be logged
LogCommandsWanted = Whether commands you type are to be logged

vbTrue = yes
vbFalse = no

-->

<muclient>
<plugin
   name="ANSI_Log"
   author="Nick Gammon"
   id="08025212f70f54d3bb25dd02"
   language="VBscript"
   purpose="Logs commands and MUD output using ANSI colours"
   date_written="2003-07-25 10:45:39"
   requires="3.35"
   version="1.0"
   >
<description trim="y">
<![CDATA[
Once installed, this plugin will log player commands, and output from the MUD, to the current log file using ANSI colour sequences.

As far as possible, the plugin will try to match the colours on the output lines to existing ANSI codes (this may fail if you are using MXP and the MUD sends non-ANSI colours).

It then generates the appropriate ANSI code and writes it to the log file.

The trigger and alias in the plugin set the "omit from log" flags so the lines are not logged twice.

They are set to "keep evaluating" so that other triggers and aliases are still processed.
]]>
</description>

</plugin>


<!--  Triggers  -->

<triggers>
  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^.*$"
   name="ansi_log"
   omit_from_log="y"
   regexp="y"
   script="LogOutput"
   sequence="5"
    >
  </trigger>
</triggers>

<!--  Aliases  -->

<aliases>
  <alias
   name="ansi_log"
   script="LogCommand"
   match="^.*$"
   enabled="y"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   keep_evaluating="y"
   sequence="5"
  >
  <send>%0</send>
  </alias>
</aliases>

<!--  Script  -->


<script>
dim PreserveLineBreaksWanted
  PreserveLineBreaksWanted = &PreserveLineBreaksWanted;
dim LogOutputWanted
  LogOutputWanted = &LogOutputWanted;
dim LogCommandsWanted
  LogCommandsWanted = &LogCommandsWanted;

<![CDATA[

'
'  Helper function to output code for bold, underline etc.
'

Function DoExtra (is_set, was_set, on_code, off_code)
  
  DoExtra = ""

  If is_set And (not was_set) Then
    DoExtra = ANSI (on_code)  ' send setting code
  ElseIf (Not is_set) And (was_set) Then
    DoExtra = ANSI (off_code) ' send resetting code
  End If  ' need to un-set it

End Function

'
'  log in ANSI colours (call from trigger/alias that matches everything)
'
sub LogOutput (name, matchingline, wildcards)

dim firstline, lastline, line, style, styles
dim logline, colour, target, bold, column
dim normal (8)
dim hilite (8)
dim lastfore, lastback, lastbold
dim lastul, lastblink, lastinverse
dim ul, blink, inverse
dim i

  '
  ' Not necessary if logging not active or not wanted
  ' 

  If (Not IsLogOpen) Or (not LogOutputWanted) Then
    Exit Sub
  End If

  ' find which line this is
  lastline = GetLinesInBufferCount

  ' now find the first line in this paragraph

  firstline = lastline - 1

  do while firstline > 0 

    if GetLineInfo (firstline, 3) then 
      exit do
    end if

    firstline = firstline - 1

  loop ' end while loop - finding start of paragraph

  '
  ' paragraph starts with first line *past* the previous newline
  '

  firstline = firstline + 1

  '
  ' paragraph can't end past where it started
  '

  if firstline > lastline then firstline = lastline

  '
  '  discard world.notes and user input
  '

  if GetLineInfo (firstline, 4) then exit sub  ' note line
  if GetLineInfo (firstline, 5) then exit sub  ' input line

  '
  ' Empty lines are a special and simple case
  '

  if firstline = lastline and GetLineInfo (firstline, 2) = 0 then 
     WriteLog ""  ' just write the blank line
     Exit Sub
  end if

  '
  ' find what the ANSI colours are for this world
  '

  for i = 1 to 8 
    normal (i) = NormalColour (i)  ' normal
    hilite (i) = BoldColour (i)  ' highlight
  next

  '
  ' process entire paragraph
  '

  logline = logline & ANSI (0)  ' reset all styles
  lastfore = 37   ' reset is white
  lastback = 40       '  on black
  lastbold = vbFalse
  lastul = vbFalse
  lastblink = vbFalse
  lastinverse = vbFalse

  for line = firstline to lastline

    styles = GetLineInfo (line, 11)   ' how many styles

    '
    '  process all styles runs in this line
    ' 

    for style = 1 to styles
  
    '
    '  find text style (ANSI code)
    '
    
    target = GetStyleInfo (line, style, 14) ' RGB colour of style text
    colour = -1
    bold = vbFalse
 
    '
    '  work out which ANSI colour it must have been by a scan
    '
    for i = 1 to 8
      ' normal colour
      if target = normal (i) then
         colour = 29 + i
         exit for
      end if
      ' bold colour
      if target = hilite (i) then
         colour = 29 + i
         bold = vbTrue
         exit for
      end if
    next  ' colour

    '
    '  if found, output that colour
    '      

    if colour <> -1 then
      '
      '  only output if colour change
      '
      if colour <> lastfore then
        logline = logline & ANSI (colour)
        lastfore = colour 
      end if

    end if  ' colour found
  
    logline = logline & DoExtra (bold, lastbold, 1, 22)
    lastbold = bold

    target = GetStyleInfo (line, style, 15) ' RGB colour of style background
    colour = -1
 
    '
    '  work out which ANSI colour it must have been by a scan
    '
    for i = 1 to 8
      ' normal colour
      if target = normal (i) then
         colour = 39 + i
         exit for
      end if  
     next ' colour

    '
    '  if found, output that colour
    '      

    if colour <> -1 then
      '
      '  only output if colour change
      '
      if colour <> lastback then
        logline = logline & ANSI (colour)
        lastback = colour 
      end if

    end if  ' colour found

    '
    ' do other styles (underline, blink, inverse)
    '

    bold = GetStyleInfo (line, style,  8) ' bold flag
    logline = logline & DoExtra (bold, lastbold, 1, 22)
    lastbold = bold

    ul = GetStyleInfo (line, style, 9) ' underline flag
    logline = logline & DoExtra (ul, lastul, 4, 24)
    lastul = ul

    blink = GetStyleInfo (line, style, 10) ' blink flag
    logline = logline & DoExtra (blink, lastblink, 3, 23)
    lastblink = blink
    
    inverse = GetStyleInfo (line, style, 11) ' inverse flag
    logline = logline & DoExtra (inverse, lastinverse, 7, 27)
    lastinverse = inverse

    '
    '  now output the text
    '

    logline = logline & GetStyleInfo (line, style,  1)
    
    next ' process the next style

  '
  '  If wanted, keep the original (soft) line breaks
  '
   
  If PreserveLineBreaksWanted And line <> lastline Then
    logline = logline & vbCrLf
  End If

  next ' end for loop - processing each line in the paragraph

  WriteLog logline

end sub  ' end of LogOutput 



sub LogCommand (name, matchingline, wildcards)
  '
  ' Not necessary if logging not active or not wanted
  ' 

  If (Not IsLogOpen) Or (not LogCommandsWanted) Then
    Exit Sub
  End If

  '
  ' simply log in default ANSI colours
  '

  WriteLog ANSI (0) & matchingline

end sub

]]>
</script>

</muclient>
