<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE muclient>

<!--History>
  * Based on http://www.gammon.com.au/forum/?id=8814 by Nick Gammon
</History-->

<!--Contributors>
  * Ansalon
  * gameshogun/techmagus
</Contributors-->

<muclient>
  <plugin
    name="Ansalon_MW_Quest_Tracker_Kender"
    author="Ansalon"
    language="Lua"
    purpose="Quest Tracker Kender Edition"
    save_state="y"
    date_written="2008-07-24"
    date_modified="2015-10-05"
    requires="4.61"
    version="1.03"
    id="0fa8dce9c73de497a1fd5164"
    >
    <description trim="y"><![CDATA[
      Remembers what a quest-giver told you to do.
    ]]></description>
  </plugin>

  <triggers>
    <trigger
      match="^@questor tells you \'(.*?)\'$"
      regexp="y"
      name="questor_line"
      script="questor_line"
      sequence="100"
      expand_variables="y"
    ></trigger>

    <trigger
      enabled="y"
      match="You ask * for a quest."
      script="start_questor_stuff"
      sequence="100"
    ></trigger>

    <!-- to-check Ansalon format -->
    <trigger
      match="@questor tells you 'You have * to complete this quest.'"
      name="questor_end"
      script="questor_end"
      sequence="10"
      expand_variables="y"
    ></trigger>

    <trigger
      match="Time left for current quest: *"
      name="questor_end2"
      script="questor_end"
      sequence="10"
      expand_variables="y"
    ></trigger>

    <trigger
      enabled="y"
      match="Your quest is ALMOST complete!"
      sequence="100"
      script="quest_done"
    ></trigger>

    <trigger
      enabled="y"
      match="You inform * you have completed * quest."
      sequence="100"
      script="quest_handed_in"
    ></trigger>

    <trigger
      enabled="y"
      match="There are * minutes remaining until you can go on another quest."
      sequence="100"
      script="quest_time_to_go"
    ></trigger>

    <trigger
      enabled="y"
      match="You may quest again in * minutes."
      sequence="100"
      script="quest_time_to_go"
    ></trigger>

    <trigger
      enabled="y"
      match="You may now quest again."
      sequence="100"
      script="quest_available"
    ></trigger>

    <!-- to-check Ansalon format -->
    <trigger
      enabled="y"
      match="You do not have to wait to go on another quest."
      sequence="100"
      script="quest_available"
    ></trigger>
  </triggers>

  <timers>
    <timer
      script="show_quest_text"
      enabled="y"
      second="30.00"
    ></timer>
  </timers>

  <script><![CDATA[
    background_colour = 0xE7FF7E
    text_colour = 0x000000
    heading_colour = 0xFF0000
    time_colour = 0x0000FF

    quest_info = {}

    require "movewindow"  -- load the movewindow.lua module
    require "serialize"
    require "commas"
    require "var"

    function quest_handed_in (name, line, wildcards)
      Send "quest"
      next_quest_time = os.time () + (30 * 60)  -- 30 mins to go
      quest_info = {}
      show_quest_text ()
    end -- quest_handed_in

    function quest_time_to_go (name, line, wildcards)
      local mins = tonumber (wildcards [1])
      if mins then
        next_quest_time = os.time () + mins * 60
      else
        next_quest_time = nil
      end -- if
      quest_info = {}
      show_quest_text ()
    end -- quest_time_to_go

    function quest_available (name, line, wildcards)
      next_quest_time = os.time ()
      quest_info = {}
      show_quest_text ()
    end -- quest_available

    function quest_done (name, line, wildcards)
      quest_info = { "Quest complete - go hand it in." }
      max_width = WindowTextWidth (win, font_id, quest_info [1])
      show_quest_text ()
    end -- quest_done

    function start_questor_stuff (name, line, wildcards)
      check (EnableTrigger ("questor_line", true))
      check (EnableTrigger ("questor_end", true))
      quest_info = {}
      max_width = 0
      var.questor = wildcards [1]
      Send "quest"
    end -- start_questor_stuff

    function questor_line (name, line, wildcards)
      local text = wildcards [1]

      if string.match (text, "^Thank you, brave ") then
        return
      end -- if

      if string.match (text, "^May the gods go with ") then
        return
      end -- if

      table.insert (quest_info, text)
      max_width = math.max (max_width, WindowTextWidth (win, font_id, "aaaaaaaaaabbbbbbbbbbccccccccccddddddddddeeeeeeeeee"))
    end -- questor_line

    function Display_Line (line, text, id, colour)
      local left = 5
      local top =  (line - 1) * font_height

      WindowText (win, id, text, left, top, 0, 0, colour)
    end -- Display_Line

    function show_when_quest_available ()
      local time_to_go = next_quest_time - os.time ()

      if time_to_go <= 0 then
        text = "You can quest again!"
      else
        text = string.format ("Time until next quest: %s", convert_time (time_to_go))
      end -- if

      max_width = WindowTextWidth (win, font_id, text)

      -- recreate the window the correct size
      WindowCreate (win,
                    0, 0,   -- left, top (auto-positions)
                    max_width + 10,     -- width
                    font_height + 5,  -- height
                    miniwin.pos_top_left,
                    2,  -- flags
                    background_colour)

        -- add the drag handler so they can move the window around
        movewindow.add_drag_handler (win, 0, 0, 0, font_height + 5)


      Display_Line (1, text, font_id, time_colour)

      WindowShow (win, true)
    end -- show_when_quest_available

    function show_quest_text ()
      if #quest_info == 0 and
        next_quest_time then
        show_when_quest_available ()
        return
      end -- one available now/soon

      -- do nothing if no quest
      if #quest_info == 0 or when_required == nil then
        return
      end -- if

      -- recreate the window the correct size
      WindowCreate (win,
                    0, 0,   -- left, top (auto-positions)
                    max_width + 10,     -- width
                    (3 + 2) * font_height + 5,  -- height
                    miniwin.pos_top_left,
                    2,  -- flags
                    background_colour)

        -- add the drag handler so they can move the window around
        movewindow.add_drag_handler (win, 0, 0, 0, (2 + 2) * font_height + 5)

      -- heading
      local text = "Quest Tracker Kender Ed."
      Display_Line (1, text, font_id, heading_colour)

      -- quest info (complete)
      for i, v in ipairs (quest_info) do
        --[[
          There's a better way to do this.

          For now, what matters is that it works.
        --]]
        if string.match(v, "Bastard thieves have stolen (.*)\!") then
          quest_target = string.match(v, "Bastard thieves have stolen (.*)\!")
        elseif string.match(v, "Seek (.*) out somewhere in the vicinity of (.*)\!") then
          quest_target, loc_room = string.match(v, "Seek (.*) out somewhere in the vicinity of (.*)\!")
        end

        if string.match(v, "Look in the area of (.*) for (.*)\!\!") then
          loc_area, loc_room = string.match(v, "Look in the area of (.*) for (.*)\!\!")
        elseif string.match(v, "That location is in the general area of (.*)\.") then
          loc_area = string.match(v, "That location is in the general area of (.*)\.")
        end

        quest_timer = string.match(v, "You have (.*) minutes to complete this quest\.")

        if i == 1 and quest_info == "Quest complete - go hand it in." then
          Display_Line (i + 1, v, font_id, text_colour)
        elseif i == 1 and quest_target ~= nil then
          Display_Line (i + 1, "TGT: "..quest_target, font_id, text_colour)
        elseif i == 2 and loc_room ~= nil and loc_area ~= nil then
          Display_Line (i + 1, "RM: "..loc_room, font_id, text_colour)
          Display_Line (i + 2, "AR: "..loc_area, font_id, text_colour)
          quest_target = nil
          loc_room = nil
          loc_area = nil
        elseif i == 4 then
          Display_Line (i - 2, "TGT: "..quest_target, font_id, text_colour)
        elseif i == 5 then
          Display_Line (i - 2, "RM: "..loc_room, font_id, text_colour)
          Display_Line (i - 1, "AR: "..loc_area, font_id, text_colour)
          quest_target = nil
          loc_room = nil
          loc_area = nil
        end

        --[[
        if quest_timer ~= nil then
          Display_Line (i + 1, v, font_id, text_colour)
        end
        --]]
      end -- for

      -- how long to go
      local time_to_go = when_required - os.time ()

      if time_to_go < 0 then
        return
      end -- if

      text = string.format ("Time left: %s", convert_time (time_to_go))
      Display_Line (3 + 2, text, font_id, time_colour)

      WindowShow (win, true)
    end -- show_quest_text

    function questor_end (name, line, wildcards)
      local text = wildcards [1]

      -- work out when quest ends
      when_required = os.time ()

      local days = string.match (text, "(%d+) days?")
      if days then
        when_required = when_required + tonumber (days) * 60 * 60 * 24
      end -- some days left

      local hours = string.match (text, "(%d+) hours?")
      if hours then
        when_required = when_required + tonumber (hours) * 60 * 60
      end -- some days left

      local minutes = string.match (text, "(%d+) minutes?")
      if minutes then
        when_required = when_required + tonumber (minutes) * 60
      end -- some days left

      check (EnableTrigger ("questor_line", false))
      check (EnableTrigger ("questor_end", false))
      show_quest_text ()
    end -- questor_end

    function OnPluginSaveState ()
      SetVariable ("enabled", tostring (GetPluginInfo (GetPluginID (), 17)))
      -- save window current location for next time
      movewindow.save_state (win)
    end -- function OnPluginSaveState

    function OnPluginInstall ()
      win = GetPluginID ()
      font_id = "fn"

      font_name = "Comic Sans MS"    -- the actual font

      -- make win so I can grab the font info
      WindowCreate (win,
                    0, 0, 1, 1,  -- 1 x 1 pixel
                    1,   -- position - irrelevant
                    2,   -- flags
                    0)   -- background colour

      check (WindowFont (win, font_id, font_name, 8))  -- normal
      font_height = WindowFontInfo (win, font_id, 1)  -- height

      -- install the window movement handler, get back the window position
      windowinfo = movewindow.install (win, miniwin.pos_top_left, 0, true)

      if GetVariable ("enabled") == "false" then
        ColourNote ("yellow", "", "Warning: Plugin " .. GetPluginName ().. " is currently disabled.")
        check (EnablePlugin(GetPluginID (), false))
        return
      end -- they didn't enable us last time
    end -- OnPluginInstall

    function OnPluginDisable ()
      WindowShow (win, false)
    end -- OnPluginDisable
  ]]></script>
</muclient>
